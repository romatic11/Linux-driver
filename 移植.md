# STM32MP1移植文档



## 1、开发环境

1. 开启FTP服务
2. 开启NFS和SSH服务
3. 交叉编译器，export进系统环境变量中
4. VScode
5. MobaXterm
6. stm32CubeMX,编写STM32代码
7. stm32CubeProgrammer烧写Linux

## 2、STM32MP1启动

支持多种从设备启动：EMMC、SD、NAND、NOR、USB、UART

![image-20250609104645156](D:/Typora%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE/image-20250609104645156.png)

## 3、TF-A

隔离硬件，为硬件提供一个安全环境并提供安全服务。

TF-A会先初始化DDR等外设，把Uboot从Flash（NAND、NOR、FLASH、SD、MMC）拷贝到DDR中。

ST官方TF-A、uboot、kernel 等源码下载链接为：[my.st.com](https://my.st.com/cas/login?service=https%3A%2F%2Fwww.st.com%2Fcontent%2Fmy_st_com%2Fen%2Fproducts%2Fembedded-software%2Fmcu-mpu-embedded-software%2Fstm32-embedded-software%2Fstm32-mpu-openstlinux-distribution%2Fstm32mp1dev.html)

原子路径：1.程序源码-> 5 、ST官方原版Linux源码-> en...

解压后：sources/arm-ostl-linux-gnueabi 目录下

![image-20250609105652008](D:/Typora%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE/image-20250609105652008.png)

### TF-A源码移植步骤

1. TF-A源码打补丁
2. 安装stm32wrapper4dbg工具
3. 编译TF-A源码

**TF-A启动流程:**

![image-20250609111635418](D:/Typora%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE/image-20250609111635418.png)

**TF-A源码编译步骤：**

1. 编译官方TF-A源码
2. 修改Makefile.sdk,更改交叉编译器
3. 编译TF-A
4. TF-A烧录到EMMC

TF-A的移植全部是修改设备树：

1、创建板子对应的设备树 文件后缀.dts  ，头文件后缀为.dtsi （**将dts编译为dtb的工具叫做DTC**）

2、修改stm32mp157d-atk.dts

3、编译     Makefile.sdk中添加新设备树名字

4、修改设备树电源管理

5、修改TF卡和EMMC设备树

6、修改USB OTG设备树

7、编译

8、烧写测试

9、修改FlashLayout

## 4、U-boot

是一种bootloader，会先初始化DDR等外设，然后将Linux内核从flash（NAND，NOR，FLASH，SD，EMMC）拷贝到DDR，最后启动Linux内核。

bootloader 软件：U-Boot、vivi、RedBoot

uboot官网：[The U-Boot Documentation — Das U-Boot unknown version documentation](https://docs.u-boot.org/en/latest/)

ST官方系统源码：![image-20250610104636306](D:/Typora%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE/image-20250610104636306.png)

### U-Boot 初次编译 

1、Ubuntu 中安装一些库

```
sudo apt-get install libncurses5-dev bison flex
```

2、获取源码

3、编译

```
		make distclean 
		make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabihf- stm32mp157d_atk_defconfig 
		make V=1 ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabihf- DEVICE_TREE=stm32mp157d-atk all 
		V=1表示编译uboot 的时候输出详细的编译过程，“-j”选项来使用多线程编译
```

4、烧写 修改.tsv

### U-Boot 命令使用

“help”或“?": 可以查看当前uboot支持的命令

bdinfo：查看板子信息

printenv：输出环境变量信息

print：当前环境的所有信息

version：查看 uboot 的版本号

bootdelay ：延时

### 环境变量操作命令 

修改环境变量：setenv 和 saveenv

新建环境变量：

```
setenv author 'console=ttySTM0,115200 root=/dev/mmcblk2p2 rootwait rw ' 
saveenv 
```

author 命令创建完成以后重启 uboot

删除环境变量 ：

```
setenv author 
saveenv 
```

### 内存操作命令

md 命令用于显示内存值 md[.b, .w, .l] address

nm 命令用于修改指定地址的内存值 nm [.b, .w, .l] address 

mm命令也是修改指定地址内存值

mw用于使用一个指定的数据填充一段内存

cp 是数据拷贝命令

cmp 是比较命令，用于比较两段内存的数据是否相等

### 网络操作命令

```
setenv ipaddr 192.168.1.250   			开发板ip地址，可以不设置，使用dhcp命令来从路由器获取IP地址。
setenv ethaddr b8:ae:1d:01:01:00        开发板的MAC地址，一定要设置。 
setenv gatewayip 192.168.1.1            网关地址
setenv netmask 255.255.255.0            子网掩码。
setenv serverip 192.168.1.249 			服务器IP地址，也就是Ubuntu主机IP地址，用于调试代码。
saveenv
```

**nfs 命令**：通过网络来分享资源

```
nfs C2000000 192.168.1.239:/home/ltl/linux/nfs/uImage 
```

**tftp命令: **通过网络下载东西到DRAM中

1. 安装tftp-hpa和tftpd-hpa

```
sudo apt-get install tftp-hpa tftpd-hpa 
sudo apt-get install xinetd
```

2. TFTP也需要一个文件夹来存放文件

```
mkdir /home/ltl/linux/tftpboot 
chmod 777 /home/ltl/linux/tftpboot 
sudo service tftpd-hpa start
```

```
tftp C2000000 uImage
```

### EMMC和SD卡操作命令

![image-20250610134234881](D:/Typora%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE/image-20250610134234881.png)

将EMMC的分区2设置为当前MMC设置分区

```
mmc dev 1 2
```

### EXT格式文件系统操作命令

**ext4ls** 命令用于查询EXT4格式设备的目录和文件信息

查询EMMC分区2中的所有的目录和文件

```
ext4ls mmc 1:2 
```

**extload** 命令用于将指定的文件读取到DRAM

**ext4wirte** 命令用于将DRAM中的数据写入到MMC设备

### BOOT 操作命令

bootm命令:  先将Linux镜像文件和设备树文件拷贝到DRAM

```
tftp c2000000 uImage 
tftp c4000000 stm32mp157d-atk.dtb 
bootm c2000000 - c4000000 
```

bootz 命令： bootz 和 bootm 功能类似，但是bootz用于启动**zImage**镜像文件

boot 和bootd命令：此命令也是用来启动Linux系统的

boot会读取环境变量**bootcmd**来启动Linux 系统，bootcmd是一个很重要的环境变量！

**网络启动：**

```
setenv bootcmd 'tftp c2000000 uImage;tftp c4000000 stm32mp157d-atk.dtb;bootm c2000000 
c4000000'  
saveenv 
boot 
```

**EMMC启动：**

```
setenv bootcmd 'ext4load mmc 1:2 c2000000 uImage;ext4load mmc 1:2 c4000000 stm32mp157d
atk.dtb;bootm c2000000 - c4000000'  
saveenv 
boot 
```

###  UMS 命令

将开发板虚拟成一个U盘

## U-boot移植

半导体厂商将uboot移植到自己的芯片上，发布出去就BSP包

我们一般参考原厂开发板，在提供的BSP包上做修改

然后将uboot和Linux kernel移植到自己的硬件上

### ST 官方的 U-boot编译测试 

1、获取到ST官方uboot源码 

2、打补丁

3、修改Makefile

4、u-boot.stm32考到烧录目录测试

### 在 U-boot 中添加自己的开发板 

1、创建默认配置文件，创建自己所使用开发板对应的默认配置文件，参考官方的EVK开发板

```
cd configs  //进入uboot的configs目录 
cp stm32mp15_trusted_defconfig stm32mp15_atk_trusted_defconfig //拷贝 
```

2、创建默认配置设备树，直接复制ST官方EVK 开发板对应的设备树

```
cd arch/arm/dts/       //进入uboot设备树目录 
cp stm32mp157d-ed1.dts stm32mp157d-atk.dts //复制.dts 
cp stm32mp15xx-edx.dtsi stm32mp157d-atk.dtsi //复制.dtsi 
cp stm32mp157a-ed1-u-boot.dtsi stm32mp157d-atk-u-boot.dtsi //复制.dtsi 
```

3、修改引用的是stm32mp15xx-edx.dtsi这个设备树**头文件**，将其改为创建的stm32mp15d-atk.dtsi

4、修改电源管理设置 stm32mp157d-atk-u-boot.dtsi

5，修改TF卡和EMMC配置

6、修改usbotg_hs 节点

7、在此配置项中 加入“stm32mp157d-atk.dtb

8、编译uboot

9、网络驱动修改，网络设备树的修改

10、网络驱动修改（PHY芯片）

11、编译测试 

12、设置一些地址相关的环境变量（setenv ipaddr 192.168.1.250 ）

13、USB OTG 设备树修改

14、添加STUSB1600 I2C子节点

15、添加usb接口相关节点 

16、在stm32mp157d-atk-u-boot.dtsi 文件中添加 usbotg_hs 节点

17、使能 boot 和 bootd 命令

18、U-boot 测试 

### bootcmd 和 bootargs 环境变量 

**bootcmd**保存着uboot默认命令，uboot倒计时结束以 后就会执行bootcmd中的命令。

**bootargs**保存着uboot传递给Linux内核的参数，比如指定Linux内核所使用的console、 指定根文件系统所在的分区等，如下面bootargs环境变量值：  console=ttySTM0,115200 root=/dev/mmcblk2p3 rootwait rw 

## U-boot图形化配置及其原理

make menuconfig：打开图形化配置界面

前提：安装ncurses库

```
sudo apt-get install build-essential 
sudo apt-get install libncurses5-dev
```

配置完后 记得保存 编译

## 5、Linux内核

### Linux 内核初次编译

1、第三方库安装

编译内核之前需要先在ubuntu上安装lzop库，否则内核编译会失败！

```
sudo apt-get update   	//先更新在安装，防止安装的时候报错 
sudo apt-get install lzop    
sudo apt-get install libssl-dev 
```

2、mkimage工具安装 

STM32MP1 编译出来的 Linux 内核镜像文件为 **uImage**，这是 uboot 所使用的内核镜像格 式，通过**在zImage镜像的前面添加0X40个字节的头部来得到uImage**，这个需要mkimage工 具来完成此工作。

```
sudo apt-get install u-boot-tools 
```

3、编译Linux系统

### Linux内核启动流程

链接脚本vmlinux.lds

Linux内核入口stext

### Linux内核移植

####  Linux内核初次编译 

#### 编译 ST官方Linux系统

1、获取到ST官方Linux源码

2、内核打补丁

3、生成默认配置文件， make xxx_defconfig”来对其进行默认配置

```
cd linux-5.4.31/         //进入到linux内核 
make ARCH=arm multi_v7_defconfig "fragment*.config" //生成默认配置文件
```

**.config文件非常重要**，Linux内核的所有配置项最终都保存在.config文件里面，最终编译 Linux内核的时候需要读取.config里面的配置项！

```
for f in `ls -1 ../fragment*.config`; do scripts/kconfig/merge_config.sh -m -r .config $f; done 
yes '' | make ARCH=arm oldconfig
```

4、修改Makefile

5、网络驱动修改（PHY芯片）

6、启动测试 

#### 在 Linux 中添加自己的开发板

1、添加开发板对应的默认配置文件 （stm32mp1_atk_defconfig 文件）

2、添加开发板对应的设备树 

3、将stm32mp157d-ed1.dts 文件里面的内容 都拷贝到stm32mp157d-atk.dts

4、修改stm32mp157d-atk.dtsi文件

5、编译stm32mp157d-atk.dts设备树

6、关闭内核模块验证 

7、关闭内核log信息时间戳 

8、编译测试

#### 烧写系统镜像到EMMC里面 

### **系统镜像打包**

将uImage和stm32mp157d-atk.dtb 打包在一起，格式为ext4格式

​	1、新建ext4格式磁盘 

​	2、将系统镜像拷贝到ext4磁盘中

9、烧写到 EMMC

## 6、Busybox根文件系统构建

移植了TF-A、Uboot和Linux kernel，就剩最后一个rootfs(根文件系统)

[BusyBox](https://busybox.net/)

#### 编译BusyBox构建根文件系统

1、修改Makefile，添加编译器

2、busybox中文字符支持 

3、配置busybox

​	①、defconfig，缺省配置，也就是默认配置选项。  

​	②、allyesconfig，全选配置，也就是选中busybox的所有功能。  

​	③、allnoconfig，最小配置。

4、编译busybox

#### 向根文件系统添加lib库

1、向rootfs 的“/lib”目录添加库文件

2、向rootfs的“usr/lib”目录添加库文件

3、创建其他文件夹 ，dev、proc、mnt、sys、tmp、etc和root等

#### 根文件系统初步测试

修改 Ubuntu 的 nfs版本配置

bootargs 环境变量设置

```
setenv bootargs 'console=ttySTM0,115200 root=/dev/nfs nfsroot=192.168.1.249:/home/ltl/linux/nfs/rootfs,proto=tcp rw ip=192.168.1.250:192.168.1.249:192.168.1.1:255.255.255.0::eth0:off'      //设置bootargs 
saveenv     //保存环境变量
```

#### 完善根文件系统 

创建/etc/init.d/rcS 文件, rcS 是个shell 脚本，Linux内核启动以后需要启动一些服务，而rcS就是规定启动哪些文件 的脚本文件。

创建/etc/fstab 文件, ，fstab在Linux开机以后自动配置哪些需要自动挂载的分区

创建/etc/inittab 文件 

使能内核uevet helper

#### 烧写根文件系统到EMMC中

根文件系统打包

对uImage和stm32mp157d-atk.dtb 打包方法一样，也是制 作ext4格式的根文件系统包

1、新建ext4格式磁盘

2、将系统镜像拷贝到ext4磁盘中 

烧写到 EMMC

```
setenv bootcmd 'ext4load mmc 1:2 c2000000 uImage;ext4load mmc 1:2 c4000000 stm32mp157datk.dtb;bootm c2000000 - c4000000' 
setenv bootargs 'console=ttySTM0,115200 root=/dev/mmcblk1p3 rootwait rw' 
saveenv  
boot 
```

## 7、Buildroot根文件系统构建 

buildroot 不仅集成了 busybox，而且还集成了各种常见的第三方库和软件，需要什么就选择什 么，就跟我们去吃自助餐一样，想吃什么就拿什么.

**buildroot 下载:** [Buildroot - Making Embedded Linux Easy](https://buildroot.org/)

####  buildroot构建根文件系统

**1 配置buildroot**

		1. 配置Target options 
		1. 配置Toolchain
		1. 配置System configuration 
		1. 配置Filesystem images 
		1. 禁止编译Linux内核和uboot 
		1. 配置Target packages 
		1. 保存配置项

![image-20250610163008625](D:/Typora%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE/image-20250610163008625.png)

**2 编译 buildroot** 

```
make -j8  //多线程编译
```

buildroot 根文件系统测试

```
setenv bootargs console=ttySTM0,115200 root=/dev/nfs nfsroot=192.168.1.249:/home/ltl/linux/nfs/rootfs,proto=tcp rw ip=192.168.1.250:192.168.1.249:192.168.1.1:255.255.255.0::eth0:off'' 
```

#### buildroot 下的 busybox 配置

1 busybox 配置 

2 busybox中文字符的支持

3 编译busybox

使用自己的busybox源码

#### buildroot 第三方软件和库的配置

使能 VSFTPD 服务

使能 SSH

#### buildroot 根文件系统测试

depmod 命令测试 

 vsftpd 测试
